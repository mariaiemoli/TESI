\chapter{Stato dell'arte} \label{cap:StatoDellArte}
%---------------------------------------------------------------------------------------------%
%Definizione dell'intestazione dei capitoli
%---------------------------------------------------------------------------------------------%
\lhead[\fancyplain{}{\footnotesize{Capitolo \thechapter}}]{}
\rhead[]{\fancyplain{}{\footnotesize{\leftmark}}}
\lfoot[\fancyplain{}{\bf \thepage}]{}
\cfoot{} %per lasciare vuoto il piè di pagina centrale
\rfoot[]{\fancyplain{}{\bf \thepage}}
%---------------------------------------------------------------------------------------------%

Questo capitolo presenta il contesto scientifico nel quale il lavoro di tesi si inserisce. In particolare descrive le differenze basilari tra le applicazioni native e quelle sviluppate con un approccio di tipo cross-platform, il metamodello Windows Phone 7 e il metamodello Android. 

\section{Applicazioni Cross-Platform}
La vastità e diversità di dispositivi e sistemi operativi presenti sul mercato porta le aziende a dover produrre e distribuire la stessa applicazione più volte, una per ciascuna delle diverse piattaforme mobili esistenti, rendendo così necessaria la ricerca di una soluzione a questo problema. In alcuni casi le aziende si affidano a più team di sviluppatori, ciascuno dei quali specializzato nello sviluppo di app per uno specifico sistema operativo, in altri casi si affidano invece a una delle strategie di sviluppo cross-platform, che verranno presentate di seguito. Attualmente esistono infatti due approcci allo sviluppo di applicazioni per dispositivi mobili: l'approccio classico, che produce applicazioni mobili native, e quello cross-platform.
\\\\
Il beneficio principale, che proviene dallo sviluppo di una {\bfseries applicazione nativa}, è quello di avere accesso a tutti i componenti hardware installati sul dispositivo:  NFC, accelerometro, GPS, fotocamera, magnetometro, sensore di prossimità, di luminosità, di posizionamento e così via. Un altro aspetto riguarda la possibilità di pubblicare l'applicazione sullo store: l'abitudine degli utenti a cercare nei negozi virtuali le applicazioni che vogliono installare sul proprio smartphone rende significativo questo vantaggio. Un'applicazione nativa installata sul dispositivo, inoltre, è accessibile anche in modalità offline, a differenza di quanto accade per le applicazioni web che, come vedremo tra poco, richiedono necessariamente la connessione a Internet. Dal punto di vista dell'utilizzo, l'interfaccia grafica nativa è più reattiva rispetto a quella interpretata dal browser perché le operazioni per la sua gestione sono svolte direttamente dal sistema, inoltre essa è più gradevole. Considerando infine un aspetto di marketing, le aziende possono sfruttare le applicazioni native per mandare messaggi promozionali in base alla geo-localizzazione dell'utente, al contrario di quanto accade per le applicazioni multipiattaforma.\\
Tuttavia lo sviluppo di un'applicazione nativa implica alti costi, tempistiche lunghe e una grande quantità di risorse laddove si voglia rendere disponibile l'applicazione per diverse piattaforme, in quanto lo stesso progetto deve essere portato avanti da diversi team, con capacità e strumenti specifici \cite{article:ref2}. Per definizione le applicazioni native sono infatti realizzate e compilate sulla base di una determinata piattaforma. Le applicazioni per iOS (iPhone, iPad e iPod), per esempio, sono scritte in Objective-C, quelle per Android sono sviluppate in Java, mentre quelle per Windows Phone 8 sono sviluppate in ambiente .NET. Esistono applicazioni tuttora sviluppate anche per i sistemi operativi meno diffusi, come RIM per Blackberry o Symbian per i vecchi Nokia.
\\\\
Una soluzione ideale, obiettivo delle piattaforme di sviluppo {\bfseries cross-platform}, potrebbe essere quella di creare e mantenere un'unica applicazione che possa funzionare su piattaforme diverse. Infatti, lo sviluppo cross-platform comporta una riduzione delle capacità richieste, della quantità di codice e dei tempi e costi di sviluppo e mantenimento, senza avere la necessità di conoscere specifiche API. Nonostante questi vantaggi le attuali piattaforme cross-platform non sembrano essere ancora del tutto mature e esenti da difetti al punto da sostituirsi completamente alla metodologia classica di sviluppo.
\\\\
Di seguito riportiamo una descrizione dei vari approcci e dei relativi tool utilizzati nello sviluppo cross-platform \cite{article:ref1}\cite{article:ref6}\cite{article:ref7}, illustrando i principali vantaggi e svantaggi di ciascuno di essi. 

\subsection {Approccio Web}
Le applicazioni sviluppate con un approccio web sono progettate per essere eseguite attraverso il web browser del dispositivo, senza che vengano installate sullo stesso: appartengono a questa categoria tutte le web application accessibili dai dispositivi mobili. La business logic dell'applicazione è implementata sul server, mentre sul client risiede unicamente l'interfaccia grafica e la logica di gestione dei dati dell'utente. Il fatto che l'applicazione si basi sull'utilizzo del browser e sia server-driven fa in modo che sia completamente indipendente dalla piattaforma. Uno dei principali vantaggi di questo approccio è il fatto di poter sfruttare gli strumenti della programmazione web, quali HTML, CSS e JavaScript. Inoltre, l'applicazione non necessita di installazione o aggiornamenti sullo specifico device, in quanto salvata sul server ed acceduta di volta in volta attraverso il web browser, rendendo così riutilizzabile l'interfaccia grafica sulle diverse piattaforme.\\
Un'importante limitazione di questo approccio è quella per cui le applicazioni prodotte non possono accedere al software e all'hardware del dispositivo, inoltre le performance dell'applicazione possono essere aggravate dall'indispensabile utilizzo del browser e del collegamento a Internet. Infine bisogna considerare che l'utente è abituato a cercare le applicazioni sullo store ufficiale, dove chiaramente non si trovano quelle appartenenti a questa categoria.\\
\\
{\itshape AppsBuilder} \cite{online:appsbuilder} e {\itshape iBuildApp} \cite{online:ibuildapp} sono dei siti che offrono la possibilità di creare gratuitamente online, in maniera semplice e senza scrivere alcuna riga di codice,  applicazioni di questo tipo. Tali servizi offrono un ambiente grafico per costruire le view dell'applicazione, le quali vengono automaticamente realizzate in linguaggio HTML5, supportando in questo modo un approccio di tipo cross-platform.\\
Il procedimento per comporre le applicazioni è simile tra i due siti e, in genere, si parte dalla definizione di un tema principale a scelta fra quelli proposti per poi andare ad aggiungere, con semplici operazioni di drag and drop, le view con i relativi contenuti, quali immagini, video e testi. AppsBuilder permette addirittura l'inserimento di file .pdf, mentre iBuildApp appare più rigido nella scelta delle risorse da poter inserire. In entrambi i casi esiste la possibilit\`a di pubblicare il prodotto finale su uno store e quindi renderlo accessibile agli utenti finali.\\
Nonostante sia facile e immediato ottenere un'applicazione con questi strumenti, il prodotto non è particolarmente soddisfacente per diversi motivi. Innanzitutto la struttura dell'applicazione è rigida in quanto si è costretti a scegliere tra uno dei template proposti e una volta scelto non esiste la possibilit\`a di modificarlo, poi la grafica è essenziale ed è la stessa su tutti i dispositivi su cui l'applicazione sarà installata, inoltre non è possibile accedere a nessuna delle API del sistema operativo nativo e non potendo scrivere codice la personalizzazione delle view è davvero riduttiva. Questo tipo di applicazioni è pertanto consigliato ad utenti inesperti che desiderano realizzare in poco tempo e senza scrivere alcuna riga di codice una piccola applicazione mobile, installabile su tutte le piattaforme.

\subsection {Approccio Ibrido}
L'approccio ibrido si colloca a metà tra le metodologie nativa e web, in quanto le applicazioni sono sviluppate utilizzando le classiche tecnologie web, ma vengono eseguite all'interno di container nativi sul device. Infatti, l'interfaccia utente è mostrata attraverso un web browser ma può essere riusata sfruttando le caratteristiche native della piattaforma, mentre le risorse hardware (fotocamera, microfono, sensori, etc.) sono rese accessibili all'applicazione ibrida attraverso un layer astratto, che rende disponibili le funzionalità del dispositivo grazie a delle API JavaScript. A differenza delle applicazioni web, le applicazioni che appartengono a questa categoria possono essere distribuite sullo store e quindi sono scaricabili e installabili sullo specifico device.\\
Tra gli svantaggi di questo approccio emerge il fatto che le performance sono inferiori rispetto a quelle delle applicazioni native, perché l'esecuzione avviene nel browser engine. Inoltre il codice JavaScript può essere interpretato in modo differente da ogni dispositivo e, per quanto riguarda l'interfaccia grafica, nonostante possa essere riutilizzata su diverse piattaforme, in genere non presenta lo stile grafico delle applicazioni native.\\
Tra i tool esistenti che si basano su questo approccio troviamo PhoneGap e MoSync, descritti di seguito. \\\\
{\itshape PhoneGap} \cite{online:phonegap} è un ambiente di sviluppo completamente open-source, sotto la licenza del progetto Apache Cordova, che permette di creare applicazioni mobili attraverso i linguaggi di programmazione web moderni (HTML, CSS e JavaScript) e le funzionalità dell'SDK, risparmiando così allo sviluppatore l'apprendimento di linguaggi meno noti come Objective-C, Java, etc. PhoneGap non dispone di un proprio IDE, al contrario lo sviluppatore si appoggia agli IDE nativi dei sistemi operativi mobile (Eclipse per Android, Xcode per iOS, etc). In questo modo non viene fornito al programmatore un ambiente di sviluppo centralizzato, ma grazie all'uso di IDE diversi PhoneGap può essere sfruttato su diversi sistemi operativi come Mac, Linux e Windows.\\
Con HTML, CSS e Javascript viene definita anche l'interfaccia grafica dell'applicazione, mostrata all'utente grazie al web browser del dispositivo.	\\
PhoneGap possiede un'API che permette di accedere alle funzionalità native del sistema operativo, quindi la logica dell'applicazione viene scritta in JavaScript e l'API PhoneGap si occuperà di gestire la comunicazione con il sistema operativo nativo. Queste caratteristiche rendono l'approccio di sviluppo un approccio cross-platform ibrido.\\
Il prodotto finale è un archivio binario dell'applicazione che può essere distribuito sulle diverse piattaforme, come se l'applicazione fosse stata implementata con linguaggi nativi: per iOS l'output è un file .ipa, per Android un file .apk, per Windows Phone un file .xap, etc. \\
Per quanto riguarda i dati, PhoneGap non gestisce alcun database locale quindi è necessaria l'interazione con un server che si occupi di procurare i dati all'applicazione client attraverso un suo database. In genere la comunicazione tra client e server avviene tramite richieste HTTP che utilizzano XML o JSON come formati per lo scambio dei dati.\\\\
{\itshape MoSync} \cite{online:mosync} è un ambiente di sviluppo open source di applicazioni ibride simile a PhoneGap. La differenza principale tra i due risiede nel fatto che MoSync offre un proprio IDE, unico per tutte le piattaforme, installabile sui sistemi operativi Windows e Mac OS. Nel caso in cui non fosse possibile implementare qualche funzionalità con JavaScript, MoSync permette di implementarle direttamente in linguaggio C++, senza incorrere in problemi di compatibilità con le specifiche piattaforme. MoSync offre, inoltre, la possibilità di integrare all'interno dell'applicazione un database SQLite, una libreria software scritta in linguaggio C che implementa un Database Management System di tipo ACID e che permette di realizzare una base di dati incorporata in un unico file.

\subsection {Approccio Interpretato}
Il codice dell'applicazione viene caricato sul dispositivo e interpretato in un secondo momento, grazie ad un interprete che esegue il codice sorgente a runtime sulla specifica piattaforma, offrendo in questo modo la possibilità di riutilizzare la logica applicativa su diverse piattaforme e quindi di supportare uno sviluppo di tipo cross-platform. Le caratteristiche hardware e software della piattaforma sono accedute tramite un framework: l'applicazione interpretata interagisce con un layer astratto per accedere alle API native del dispositivo e sfrutta gli elementi dell'interfaccia grafica della specifica piattaforma, offrendo all'applicazione un'interfaccia utente che corrisponde a quella dell'applicazione nativa. \\
I principali problemi riguardano le performance che possono degradare drasticamente per via dell'interpretazione del codice a runtime e in generale lo sviluppo e il riutilizzo dell'interfaccia utente dipendono fortemente dal livello di astrazione del framework scelto.
Tra le piattaforme di sviluppo che seguono questo approccio troviamo Rhodes e Appcelerator Titanium.\\\\
{\itshape Rhodes} \cite{online:rhodes} è un ambiente di sviluppo open-source basato su Ruby e creato per sviluppare applicazioni interpretate per iOS, Android, BlackBerry, Windows Mobile e Windows 8. Un'applicazione scritta con Rhodes è una web application che può essere eseguita direttamente sul dispositivo mobile e che viene implementata sfruttando il pattern MVC, dove le view sono un insieme di template HTML (che possono contenere del codice Ruby), CSS e file JavaScript che possono essere eseguiti da un piccolo web server locale presente sullo smartphone, il controller è costituito da un insieme di script Ruby salvati in file con estensione .rb e che possono accedere ad alcune caratteristiche del dispositivo, mentre il model è costituito anch'esso da script Ruby salvati come file .rb. Inoltre, le applicazioni costruite con Rhodes possono usare database locali come SQLite.
\\\\
{\itshape Appcelerator Titanium} è framework open-source per scrivere applicazioni mobili basato esclusivamente su un SDK Javascript. Può essere scaricato sia nella versione stand-alone, che comprende una versione di Eclipse già configurata per lo sviluppo di applicazioni mobili, sia come plugin. In quest'ultimo caso è necessario installare anche l'SDK della piattaforma per cui si intende sviluppare. I programmatori scrivono tutto il codice sorgente unicamente in JavaScript e tramite le API del framework possono accedere alle funzionalità del sistema e definire l'interfaccia grafica. Durante la compilazione Titanium combina i codici sorgenti con un interprete JavaScript e altri contenuti statici in un application package, mentre a runtime l'interprete processa codice Javascript. Per queste ragioni Titanium, come Rhodes, appartiene alla categoria di ambienti per lo sviluppo di applicazioni interpretate.

\subsection {Approccio Cross-Compilato}
Le applicazioni vengono scritte dallo sviluppatore in un linguaggio di programmazione comune e un cross-compiler è responsabile della traduzione del codice sorgente in file binari nativi. Questo approccio è pertanto strettamente dipendente dall'efficienza e affidabilità del cross-compiler. Il vantaggio di questo approccio è che le applicazioni prodotte hanno accesso a tutte le caratteristiche native della piattaforma e tutti i componenti dell'interfaccia grafica nativa possono essere utilizzati senza problemi. \\
Il problema è che l'interfaccia grafica non può essere riutilizzata, così come le caratteristiche hardware native. Queste caratteristiche, infatti, dipendono dalla specifica piattaforma e il modo di accedervi è strettamente legato ad essa. Inoltre l'approccio non è adatto per lo sviluppo di applicazioni sofisticate, dove la cross-compilazione diventa complicata.
I due tool più utilizzati che sfruttano questo approccio sono Xamarin e Corona.\\\\
{\itshape Xamarin} \cite{online:xamarin} è un ambiente di sviluppo per applicazioni cross-compilate che permette al programmatore di utilizzare il linguaggio C\# per scrivere applicazioni eseguibili su piattaforme Android e iOS. Il compilatore Xamarin offre tutte le API native di iOS e Android come normali librerie C\#, permettendo così l'accesso a tutte le caratteristiche hardware dello specifico device. Per eseguire il codice sul dispositivo, Xamarin si appoggia a Mono, un'implementazione open source del framework Microsoft .NET, che prende il posto della macchina virtuale nativa del sistema operativo, producendo così lo stesso output su piattaforme diverse.
\\\\
{\itshape Corona} \cite{online:corona} è un ambiente di sviluppo che consente di creare applicazioni mobili secondo un approccio cross-compilato, appoggiandosi al linguaggio di programmazione Lua per astrarre lo sviluppo dell'applicazione da uno specifico sistema operativo. Corona possiede un proprio IDE e può essere scaricato in diverse versioni a partire da quella gratuita con funzionalità limitate sino ad arrivare alla versione enterprise ricca di funzionalità, come l'integrazione con le librerie native. Corona possiede anche un proprio SDK che viene costantemente aggiornato dalla community ed un proprio simulatore. Questo tool è considerato particolarmente utile per l'implementazione di videogiochi, ma risulta inadatto allo sviluppo di applicazioni mobili tradizionali.

\subsection {Altri approcci}
La classificazione riportata sopra, sebbene copra la maggior parte degli approcci cross-platform che concorrono allo sviluppo di applicazioni mobili, non è esaustiva per via del fatto che il mondo delle applicazioni mobili è in continua evoluzione, portando sempre nuovi strumenti e metodologie di sviluppo. Uno strumento che non segue nessuno fra gli approcci sopra citati è DragonRAD.
\\\\
{\itshape DragonRAD} \cite{online:dragonrad} è un ambiente di programmazione distribuito con licenza commerciale e dotato di un proprio IDE, che permette lo sviluppo di applicazioni per iOS, Android, BlackBerry e Windows Mobile. La piattaforma è stata progettata con l'obiettivo di semplificare il design, lo sviluppo, il mantenimento e l'amministrazione di applicazioni mobili database-driven, senza la necessità di dover scrivere righe di codice, usando il tool grafico incluso nel framework, che offre un intuitivo ambiente drag and drop. Ai fini di soddisfare sofisticati requisiti applicativi DragonRAD offre anche un supporto per poter scrivere degli script in linguaggio Lua. \\
DragonRAD ha un'architettura host-client, che offre un pacchetto completo con tutti i prerequisiti per accogliere i server e database più noti (Tomcat, MySql, etc): è richiesto il setup del server e del database, in base alle esigenze dello sviluppatore. In questo modo DragonRAD facilita l'integrazione e la sincronizzazione del database sul server con le funzioni native delle piattaforme mobili: contatti, calendario, geolocation, etc. Una limitazione di DragonRad è il fatto di essere usato principalmente per sviluppare applicazioni enterprise, che richiedono la sincronizzazione con sistemi di backend, quindi non è del tutto indicato a sviluppatori di applicazioni stand-alone.

\section {Metamodelli UML esistenti}
Nella modellazione di applicazioni basate sulla programmazione ad oggetti il linguaggio maggiormente utilizzato è UML (Unified Modeling Language). Le proposte presentate finora in merito alla realizzazione di metamodelli per applicazioni mobili si basano proprio sull'estensione di questo linguaggio di natura general purpose, che, in quanto tale, da solo non potrebbe garantire una completa descrizione di una specifica applicazione mobile. Per metamodello si intende un modello di specifica per una classe di sistemi, in cui ogni sistema è rappresentato da un modello valido, espresso in un certo linguaggio di modellazione. Il metamodello UML in particolare contiene elementi che permettono di modellare in maniera semplice oggetti e relazioni tra di essi. \\
Passiamo dunque ad analizzare i metamodelli UML presenti in letteratura per le piattaforme {\itshape Windows Phone 7} e {\itshape Android} \cite{article:ref4} \cite{article:ref5}.

\subsection {Metamodello Windows Phone 7}
Gli autori nel loro lavoro \cite{article:ref4} partono dall'idea di voler definire un metamodello in grado di esprimere ad alto livello le caratteristiche fondamentali delle applicazioni sviluppate per il sistema operativo Windows Phone 7. Dopo un analisi approfondita della struttura della piattaforma presentano una classificazione delle caratteristiche, che vengono suddivise in caratteristiche software e caratteristiche hardware. Gli elementi software sono usati per definire un modello che descriva la struttura di una generica applicazione, mentre gli elementi hardware sono usati per descrivere l'utilizzo delle risorse hardware da parte dell'applicazione. In questo modo gli autori riescono a modellare indipendentemente la parte software e la parte hardware e, al momento della migrazione di un'applicazione sviluppata per uno smartphone su un dispositivo appartenente ad un'altra categoria, come un tablet o uno smartbook, è richiesta unicamente la modifica delle parti relative alle risorse hardware, in quanto le parti software rimangono invariate. Entrambe le parti, descritte in dettaglio di seguito, sono state modellate appoggiandosi al linguaggio UML e ampliandolo con degli stereotipi.

\subsubsection{Caratteristiche Software}
Gli stereotipi che descrivono le caratteristiche software del sistema operativo sono stati definiti seguendo il pattern MVC (Model View Controller), dove il Model rappresenta i contenuti, la View costituisce l'interfaccia grafica che mostra i contenuti, e il Controller contiene la logica applicativa dell'applicazione, che controlla i contenuti e l'interfaccia grafica. In Figura \ref{fig:WPSoft} è mostrato il metamodello del software, dove è possibile notare l'utilizzo del pattern MVC tra gli stereotipi che modellano l'applicazione.
\\\\
Il {\bfseries Model} rappresenta unicamente le classi che presentano contenuti e che mantengono l'informazione durante l'esecuzione dell'applicazione. Al verificarsi di un certo evento è poi il {\bfseries Controller} che si occupa di estrarre i contenuti dal Model e mostrarli sull'interfaccia utente. La classe Controller è quindi indicata nel metamodello del software con lo scopo di modellare l'identificazione e il controllo del flusso di dati tra gli elementi del sistema. La {\bfseries View} è invece relazionata all'interfaccia grafica, perciò richiede di essere implementata con attenzione, ai fini di soddisfare l'utente utilizzatore dell'applicazione. Per quanto riguarda la parte grafica a design time non è semplice determinare quale elemento verrà usato, infatti i dispositivi, smartphone o tablet che siano, possono avere diverse tipologie di componenti dell'interfaccia. Per questo motivo, a design time, gli autori hanno preferito indicare nel metamodello lo stereotipo View, che rappresenta in maniera astratta l'insieme dei componenti grafici. Il componente specifico viene poi determinato in fase di implementazione, dopo aver stabilito il target device.
\begin{figure}[h!]
	\centering
		\includegraphics[scale=0.7]{Figure/Cap1/WP_Software.pdf}
		\caption{{\itshape WP7}: Metamodello del software}
		\label{fig:WPSoft}
\end{figure}

\subsubsection{Caratteristiche Hardware e Funzioni Fondamentali}
Nel metamodello Windows Phone 7 per caratteristiche hardware si intende l'insieme di tutte le risorse hardware del dispositivo accessibili dall'applicazione sviluppata. Le classi che contribuiscono alla modellazione di questo genere di risorse corrispondono anche in questo caso a degli stereotipi e sono riportate in Figura \ref{fig:WPHard}. Per problemi di spazio nel modello presentato sono riportate solo alcune delle svariate risorse normalmente disponibili all'interno di un dispositivo, ovvero quelle che gli autori hanno considerato essere le più utilizzate. Tra le risorse modellate troviamo l'accelerometro, il GPS, il microfono, la fotocamera e il sensore di rete.
\begin{figure}[h!]
	\centering
		\includegraphics[scale=0.7]{Figure/Cap1/WP_Hardware.pdf}
		\caption{{\itshape WP7}: Metamodello delle risorse hardware}
		\label{fig:WPHard}
\end{figure}
\\\\
Oltre alla risorse hardware sono state modellate anche alcune delle funzioni fondamentali rese disponibili dal sistema operativo con lo scopo di migliorare l'user experience e le performance dell'applicazione. Tali funzioni sono riportate in Figura ~\ref{fig:WPFondFunct}. 
\begin{figure}[h!]
	\centering
		\centering
		\includegraphics[scale = 0.7]{Figure/Cap1/WP_MainResources.pdf}
		\caption{{\itshape WP7}: Metamodello delle funzioni fondamentali}
		\label{fig:WPFondFunct}
\end{figure}
La prima di esse è l'{\itshape Isolate Storage}, un meccanismo di archiviazione dei dati supportato da Windows Phone 7 che offre isolamento e sicurezza. Con l'Isolate Storage i dati sono infatti protetti da apposite applicazioni che dispongono dell'accesso allo spazio di memorizzazione isolato ~\cite{online:windowsphonestorage}. Un'altra funzione, chiamata {\itshape Security}, è un aspetto rilevante nei dispositivi mobili che sfruttano tecnologie come l'accelerazione dell'hardware, le quali possono essere utilizzate a scopi malevoli. In Silverlight, la piattaforma per lo sviluppo di applicazioni Windows Phone 7, esiste il concetto di sandbox, che fornisce un ambiente in cui le applicazioni, per questioni di sicurezza, hanno privilegi limitati e non hanno accesso al file system e alle altre risorse: ogni applicazione è eseguita all'interno della propria sandbox. I programmatori che nello sviluppo della loro applicazione necessitano di accedere alle caratteristiche del dispositivo possono sfruttare delle API chiamate {\itshape Launcher} e {\itshape Chooser}. Le Launcher sono utilizzate per invocare applicazioni che non ritornano alcun tipo di dato all'applicazione chiamante, mentre le Chooser invocano applicazioni finalizzate a ritornare dati all'applicazione che le ha chiamate \cite{online:windowsphonesecurity}.

\subsection {Metamodello Android}
Un'applicazione Android è costituita da una serie di interfacce utente, risorse e altri concetti che concorrono al suo corretto funzionamento: molti di questi elementi si prestano ad essere modellati nel momento in cui il programmatore decide di sviluppare un'applicazione. L'articolo \cite{article:ref5} riporta una soluzione alla modellazione di questi elementi, presentati anche in questo caso come stereotipi del linguaggio UML. Attraverso lo stereotipo UML si riesce infatti a sfruttare ed estendere il linguaggio di modellazione senza dover necessariamente cambiare la sua notazione o sintassi. Il lavoro svolto dagli autori consiste, in particolare, nell'identificazione e nell'analisi delle caratteristiche della piattaforma Android e nella conseguente produzione di un metamodello UML esteso, in grado di offrire allo sviluppatore un insieme esaustivo di elementi di modellazione, utili nella fase di design delle applicazioni per questa piattaforma.
\\\\
Gli autori classificano le caratteristiche della piattaforma Android in strutturali e dinamiche, che comprendono rispettivamente gli elementi base che formano l'applicazione e i metodi usati dagli sviluppatori per controllare il comportamento di tali elementi.

\subsubsection{Caratteristiche strutturali}
Le caratteristiche strutturali comprendono l'interfaccia utente, le risorse di sistema e i componenti fondamentali che caratterizzano una qualsiasi applicazione Android. 
\\\\
L'{\bfseries interfaccia utente} è una parte fondamentale per tutte le applicazioni mobili e Android mette a disposizione molti strumenti per personalizzare le schermate mostrate. I componenti dell'interfaccia grafica sono i {\itshape Widget} (Button, TextView, WebView, ImageView, etc.) e gli {\itshape UI Event Processing}, ovvero gli elementi che processano gli eventi scatenati dall'utente che interagisce col dispositivo. \\
Tutta questa parte è stata modellata seguendo il pattern MVC: gli elementi grafici sono stati definiti aggiungendo gli stereotipi {\itshape Controller} e {\itshape Model}, come mostrato in Figura \ref{fig:AndroidUI}. Non è presente un vero e proprio stereotipo View per via del fatto che sono stati esplicitamente indicati concetti come {\itshape UIControlButton}, che modella gli elementi Button e ImageButton, {\itshape UIControlViewer}, che modella gli elementi ListView, WebView e MapView e {\itshape UIControlText}, che modella gli elementi EditText e TextView.
\begin{figure}[h!]
\centering
\includegraphics[scale = 0.7]{Figure/Cap1/Android_GUI.pdf}
\caption{{\itshape Android}: Metamodello dell'interfaccia grafica}
\label{fig:AndroidUI}
\end{figure}
\\\\
Le {\bfseries risorse di sistema} sono invece costituite dalle {\itshape Librerie Esterne}, ovvero le librerie di sistema di cui fa uso l'applicazione, dalle {\itshape Content Resource}, intese come i file audio, i file di testo, le immagini e tutti gli altri file multimediali utilizzati dall'applicazione, e dalle {\itshape Risorse Hardware}, che rappresentano i componenti hardware e sensori del dispositivo a cui l'applicazione richiede l'accesso. \\
Per queste risorse sono stati definiti gli sterotipi {\itshape ResourceController} e {\itshape ExternalLibrary}, mostrati in Figura \ref{fig:AndroidSystemResources}. Il primo, indicato come figlio dell'elemento Class, è stato introdotto per modellare la gestione delle Content Resource e delle risorse hardware, mentre il secondo, definito come figlio del concetto Subsystem del linguaggio UML, è stato introdotto per modellare le librerie di sistema esterne. Per le risorse hardware è stato poi definito un metamodello molto simile a quello presentato per modellare le caratteristiche hardware della piattaforma Windows Phone 7, che abbiamo quindi preferito non riportare.
\begin{figure}[h!]
\centering
\includegraphics[scale = 0.7]{Figure/Cap1/Android_SystemResources.pdf}
\caption{{\itshape Android}: Metamodello delle risorse di sistema}
\label{fig:AndroidSystemResources}
\end{figure}
\\\\
I {\bfseries componenti fondamentali} che caratterizzano le applicazioni Android sono i seguenti:
\begin{itemize}
	\item {\bfseries Activity}: componente dell'applicazione che fornisce una schermata con cui l'utente può interagire per svolgere determinate operazioni. Ogni Activity agisce infatti all'interno di una window nella quale si trova l'interfaccia grafica. Un'applicazione solitamente è costituita da più Activity collegate tra loro: una fra queste viene mostrata per prima e in genere viene definita MainActivity. Quando viene attivata una nuova Activity, quella precedente viene arrestata e inserita nel ``back stack'', che funziona seguendo una logica di tipo ``last-in first-out''. Nel momento in cui viene premuto il tasto ``back'' sul dispositivo l'Activity corrente viene rimossa dallo stack e quella precedente viene mostrata a schermo. Se una generica Activity viene fermata riceve una notifica del cambiamento di stato attraverso i metodi di callback del ciclo di vita, che come vedremo più avanti sono utilizzati per gestire la sua creazione, ripresa e distruzione ~\cite{online:androidactivity}.	
	\item {\bfseries Service}: componente dell'applicazione che non presenta un'interfaccia utente e che viene utilizzato per eseguire operazioni di lunga durata che non richiedono l'interazione con l'utente, come la riproduzione di brani musicali o il download di immagini da Internet, oppure per rendere disponibile una certa funzionalità ad altre applicazioni installate sul dispositivo ~\cite{online:androidservice}.
	\item {\bfseries Content Provider}: componente che gestisce l'accesso ai dati strutturati dell'applicazione che devono essere condivisi con le altre applicazioni. I Content Provider delle applicazioni incapsulano i dati e forniscono meccanismi per definire la sicurezza dei dati. Per accedere ai dati di un certo Content Provider, nel contesto dell'applicazione che si sta sviluppando, si utilizza l'oggetto Content Resolver, che funge da client nella comunicazione col provider e il cui compito è quello di rispondere alle richieste. Il Content Provider è pertanto necessario solo nel caso si voglia costruire un'applicazione che condivide i suoi dati con altre applicazioni \cite{online:androidcontentprovider}. 	
	\item {\bfseries Broadcast Receiver}: componente dell'applicazione in grado di ricevere gli annunci dal sistema finalizzati a notificare determinati eventi. Il Broadcast Receiver è sempre in ascolto e i messaggi inviati e ricevuti riguardano informazioni di vario genere: notifica di batteria scarica, notifica della perdita del segnale GPS, notifica di chiamata o sms in entrata, etc.
\end{itemize}
Poiché ogni componente viene eseguito singolarmente, Android mette a disposizione un oggetto {\bfseries Intent} per far comunicare i componenti a runtime.\\
I componenti fondamentali sono riportati in Figura \ref{fig:AndroidFoundamentalComponents}, dove si può notare come siano stati tutti definiti come figli dell'elemento Class. L'elemento Intent invece è presentato come figlio di Attribute ed è associato all'elemento {\bfseries Navigation}, figlio di Association, ai fini di modellare il ruolo di intermediario rivestito dall'oggetto Intent nei confronti dei quattro componenti base di cui sono composte le applicazioni Android.
\begin{figure}[h!]
\centering
\includegraphics[scale=0.7]{Figure/Cap1/Android_StructuralFeatures.pdf}
\caption{{\itshape Android}: Metamodello dei componenti fondamentali}
\label{fig:AndroidFoundamentalComponents}
\end{figure}

\subsubsection{Caratteristiche dinamiche}
In un'applicazione Android ogni componente fondamentale ha un particolare ciclo di vita che inizia con la sua creazione e si conclude con la distruzione, che nel caso delle Activity avvengono rispettivamente con l'aggiunta e la rimozione delle stesse dallo stack presentato in precedenza. Le caratteristiche dinamiche definite dagli autori per la piattaforma Android cercano di modellare proprio la gestione del ciclo di vita dei componenti fondamentali Activity e Service. Per questo motivo nel metamodello è stato introdotto anche uno stereotipo {\itshape LifeCicle}, definito come figlio di Operation, in quanto in Android la gestione del ciclo di vita di questi componenti avviene sulla base dell'implementazione di questi metodi.

\section{Conclusioni}
In questo capitolo abbiamo presentato alcuni approcci allo sviluppo di applicazioni mobili, citando per ciascuno di essi principali benefici e limitazioni. Abbiamo descritto nel dettaglio la metodologia cross-platform, che prevede lo sviluppo di un'unica applicazione installabile su più piattaforme. I problemi principali di questa metodologia sono riconducibili all'impossibilità di sfruttare tutte le API native del sistema operativo, ad avere performance limitate e, nel caso delle applicazioni sviluppate con un approccio web, all'essere vincolati a dover sfruttare il browser per utilizzare l'applicazione. \\
In ogni caso i problemi di compatibilità delle applicazioni sui diversi dispositivi non sono legati unicamente al sistema operativo, ma anche al fatto che ciascun device presenta uno schermo con risoluzione e dimensioni specifiche, processori grafici più o meno potenti ed in generale caratteristiche hardware differenti. Sorge pertanto la necessità di uno studio approfondito dei dispositivi esistenti e dei loro sistemi operativi da un punto di vista astratto, modellistico.\\
In seguito alla presentazione delle metodologie di sviluppo esistenti abbiamo descritto due approcci concreti alla modellazione delle applicazioni mobili, entrambi basati sull'estensione del linguaggio UML e finalizzati alla definizione di un metamodello per una specifica piattaforma: per quanto interessanti, questi approcci non offrono direttamente un contributo pratico allo sviluppo di applicazioni multipiattaforma. Da qui nasce la necessità di analizzare nel dettaglio le analogie e le differenze che risiedono nella struttura delle applicazioni mobili appartenenti alle diverse piattaforme presenti sul mercato, e astrarre la modellazione dallo specifico sistema operativo.
\\\\
Nel capitolo successivo entreremo nel dettaglio del lavoro di tesi presentando il primo dei risultati ottenuti, vale a dire il metamodello astratto, da noi definito come strumento di supporto alla fase di progettazione delle applicazioni mobili, indipendentemente dalla piattaforma per cui vengono realizzate.