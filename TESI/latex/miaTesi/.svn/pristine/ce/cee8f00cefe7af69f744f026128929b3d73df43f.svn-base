\chapter{Metamodello astratto} \label{cap:MetamodelloAstratto}
%---------------------------------------------------------------------------------------------%
%Definizione dell'intestazione dei capitoli
%---------------------------------------------------------------------------------------------%
\lhead[\fancyplain{}{\footnotesize{Capitolo \thechapter}}]{}
\rhead[]{\fancyplain{}{\footnotesize{\leftmark}}}
\lfoot[\fancyplain{}{\bf \thepage}]{}
\cfoot{} %per lasciare vuoto il piè di pagina centrale
\rfoot[]{\fancyplain{}{\bf \thepage}}
%---------------------------------------------------------------------------------------------%

In questo capitolo presentiamo il nostro metamodello per le applicazioni mobili. L'obiettivo della fase di modellazione è quello di identificare ad alto livello i principali elementi comuni e le eventuali discordanze che possono esistere all'interno della struttura di applicazioni native di piattaforme diverse. Nel nostro caso la modellazione è stata definita a seguito di uno studio approfondito dei sistemi operativi Android e iOS, ma in generale il metamodello definito può essere considerato valido per una qualsiasi piattaforma mobile.
\\\\
Come punto di partenza della fase di modellazione è stato scelto il linguaggio UML che, in quanto standard di specifica dei modelli di sviluppo, permette di rendere il nostro metamodello il più possibile universale.
\\
Così come i metamodelli Android e Windows Phone 7 esistenti, il nostro metamodello comprende una frazione esistente dei concetti UML, ben conosciuta nei modelli di sviluppo per linguaggi ad oggetti, ed una parte nuova finalizzata all'introduzione di nuovi concetti specifici, che costituiscono i componenti base delle applicazioni mobili.

\section{Parte esistente del metamodello}
I concetti e le relazioni del linguaggio UML che compongono la parte esistente del metamodello sono riportati in Figura \ref{fig:metamodelloParteEsistente} e descritti di seguito \cite{online:uml} \cite{online:umldiagrams}.
\begin{figure}[h!]
\centering
\includegraphics[scale=0.7]{Figure/Cap2/Metamodel-ExistingPart.pdf}
\caption{{\itshape Metamodello Astratto}: parte esistente.}
\label{fig:metamodelloParteEsistente}
\end{figure}
\begin{itemize}
\item {\bfseries Classifier}: è un elemento UML che descrive un insieme di istanze con le stesse caratteristiche (Feature) strutturali e/o comportamentali. Il Classifier rappresenta una metaclasse astratta utile a generalizzare concetti che possono avere delle istanze, come Class, Interface e Subsystem.
\item {\bfseries Association}: è una relazione binaria o n-aria tra Classifier utilizzata per mostrare che le istanze di uno o più Classifier possono essere collegate tra loro o combinate in aggregazioni. Tale concetto si contraddistingue da quello di {\itshape Generalization}, che rappresenta invece una relazione tassonomica tra un concetto più generale e uno più specifico. \\
Talvolta un Classifier può essere definito attraverso una composizione di altri Classifier: questo è un tipo speciale di Association binaria denominata {\itshape Aggregation}, dove abbiamo da una parte il componente aggregato e dall'altra tutte le sue parti. Oltre ad Aggregation esiste la {\itshape Composition}, che rappresenta un tipo più forte di aggregazione: ogni sottocomponente in una Composition può appartenere ad un solo componente aggregato e quindi nel momento in cui quest'ultimo viene eliminato, anche tutte le sue parti vengono rimosse. Per questioni di spazio abbiamo preferito non riportare in Figura \ref{fig:metamodelloParteEsistente} questi ultimi concetti dello standard UML.
\item {\bfseries Subsystem}: è un componente, ovvero un Classifier, che rappresenta un'unità indipendente del sistema. Viene usato generalmente per descrivere parti molto grandi di un sistema complesso.
\item {\bfseries Feature}: è un elemento che rappresenta una caratteristica strutturale o comportamentale di un Classifier o delle sue istanze. Le Feature non hanno una notazione propria, la quale è definita in maniera specifica dalle sue sottoclassi. Le possibili sottoclassi di Feature sono Attribute, che rappresentano le caratteristiche strutturali, Operation, che, invece, rappresentano le caratteristiche comportamentali e AssociationEnd. Quando una Feature è una AssociationEnd il suo valore o i suoi valori sono legati all'istanza o alle istanze del Classifier all'altro lato dell'Association di cui fa parte. 
\item {\bfseries Attribute}: è una proprietà, ovvero una Feature, di un Classifier che definisce una sua particolare caratteristica strutturale e quindi la struttura delle sue istanze. Il contesto dell'attributo è il Classifier in cui si trova.
\item {\bfseries Operation}: è una Feature di un Classifier che, invocata su una sua istanza, definisce una sua particolare caratteristica comportamentale e quindi specifica il nome, il tipo, i parametri e vincoli che caratterizzano tale caratteristica per invocare il comportamento associato. Nella programmazione ad oggetti le Operation sono spesso chiamate metodi.
\item {\bfseries AssociationEnd}: è considerata parte di una Association e rappresenta il tipo e la cardinalità di un'entità (Classifier) appartenente a una delle estremità dell'associazione. Ogni associazione binaria deve avere esattamente due AssociationEnd, ciascuna delle quali può avere un nome che indica il ruolo all'interno della associazione e una serie di proprietà che determinano la semantica di come il Classifier all'estremità partecipa alla relazione, tra cui in genere compare la cardinalità, indicante il numero di istanze del relativo Classifier partecipanti all'associazione.
\item {\bfseries Class}: è un Classifier che descrive un insieme di oggetti che condividono le stesse Feature, gli stessi vincoli e la stessa semantica, ovvero lo stesso significato. Tale elemento può avere da zero a molte Feature, ciascuna delle quali può essere statica o non statica: le Feature statiche rappresentano le caratteristiche del Classifier, mentre quelle non statiche sono da riferirsi alle singole istanze del Classifier.
\item {\bfseries Type}: è una metaclasse astratta che rappresenta un insieme di valori ed è usata come vincolo per l'intervallo di valori ammissibili da un TypedElement. 
\item {\bfseries TypedElement}: è una metaclasse astratta con un Type associato allo scopo di vincolare l'intervallo di valori che può assumere. Tuttavia esistono casi in cui il TypedElement non ha un Type e in tal caso può rappresentare valori di qualsiasi tipo.
\item {\bfseries Parameter}: è un TypedElement che rappresenta un parametro di una Operation. Ogni parametro di un'operazione ha un Type e una cardinalità e, al momento dell'invocazione di un'operazione su un Classifier, viene passato un argomento per ciascuno dei suoi parametri. Nel diagramma è specificata la cardinalità 0..1 sulla composizione che lega Parameter a Operation perchè in UML esistono casi in cui le sottoclassi di Parameter non sono necessariamente associate a un'operazione.
\end{itemize}
Tutti questi elementi del linguaggio UML rispecchiano essenzialmente la struttura dei linguaggi Java, C\# e C++, ma si adattano molto bene anche ad altri linguaggi ad oggetti, come Objective-C che sta alla base dello sviluppo di applicazioni per iOS.

\section{Parte nuova del metamodello}
In fase di studio delle piattaforme Android e iOS abbiamo riscontrato numerose differenze di base. Prima di tutto le applicazioni appartenenti alle due piattaforme sono sviluppate appoggiandosi a linguaggi diversi: nel caso di Android si utilizza prevalentemente il linguaggio Java, mentre nel caso iOS si utilizza Objective-C. Anche gli strumenti e i pattern architetturali utilizzati sono differenti, infatti le applicazioni iOS sono strutturate seguendo fortemente il pattern MVC, mentre in quelle Android la distinzione tra i ruoli Model, View e Controller non è così netta. Con questa premessa si inizia a capire che il risultato dell'analisi svolta sulle due piattaforme è frutto di un compromesso, che, in fase di modellazione, cerca di riassumere nel modo più completo e preciso possibile la struttura delle applicazioni di entrambe.
\\\\
Tra gli elementi del linguaggio UML, oltre a quelli presentati in precedenza a introduzione della parte esistente del metamodello, è di fondamentale importanza l'elemento {\bfseries Stereotype}, che permette di estendere i concetti esistenti nel linguaggio di modellazione per definirne dei nuovi, personalizzati. Infatti, grazie all'utilizzo di questo elemento è stato possibile delineare nuovi concetti relativi alle applicazioni mobili, introdotti di seguito e rappresentati in Figura \ref{fig:metamodelloParteEstesa}, dove è mostrata la struttura ad alto livello del metamodello.
\begin{figure}[h!]
\centering
\includegraphics[width=\textwidth]{Figure/Cap2/Metamodel-HighLevel.pdf}
\caption{{\itshape Metamodello Astratto}: parte nuova.}
\label{fig:metamodelloParteEstesa}
\end{figure}
\\
Per facilitare al lettore la distinzione della parte esistente da quella nuova del metamodello, abbiamo posto in alto, nella figura, alcuni degli elementi appartenenti alla parte esistente del metamodello, che a differenza di quelli nuovi non presentano l'etichetta Stereotype. Il diagramma è stato definito evitando di lasciare elementi isolati, perciò ciascun elemento è relazionato ad un concetto UML esistente o ad un elemento della parte nuova. Il fulcro del metamodello è rappresentato dallo stereotipo {\bfseries Application}, da cui partono diverse composizioni. Abbiamo scelto di lasciare questo elemento privo di generalizzazioni in quanto lo consideriamo l'elemento cardine del metamodello. Osservando la Figura \ref{fig:metamodelloParteEstesa} è immediato individuare le composizioni che partono dall'oggetto Application, che risulta essere così composto dai seguenti elementi:
\begin{itemize}
\item {\bfseries Class}: elemento appartenente alla parte esistente del metamodello e che rappresenta per Application la possibilità di includere delle generiche classi di supporto definite dal programmatore in fase di implementazione. Rientrano in questa categoria le classi per interfacciarsi con il database, le classi di supporto contenenti costanti e metodi statici pubblici accessibili dalle altre classi dell'applicazione, etc.\\
La relazione tra Application e Class è una composizione con cardinalità da zero a molti verso Class, che bisogna intendere come la possibilità per Application di avere da zero a molte classi di supporto, al contrario la cardinalità pari a uno verso Application indica che ogni istanza di Class appartiene ad un'unica applicazione.
\item {\bfseries Manifest}: in Android si tratta di un file che permette di specificare tutte le Activity presenti nell'applicazione, i permessi e i temi che si intendono utilizzare. In ambiente iOS questo concetto si concretizza come l'insieme dei file di configurazione autogenerati dal tool Xcode che servono a definire la Window principale, la categoria dell'applicazione e in generale a gestire la compatibilità sui device di casa Apple. Nessuna applicazione può funzionare se non dispone di queste informazioni, per questo sulla relazione di composizione che lega i due elementi la cardinalità è uno in entrambi i sensi: l'istanza dell'elemento Manifest non può che avere una sola applicazione di riferimento, mentre ogni applicazione ha un unico Manifest, rappresentato nel metamodello come concetto generico, ovvero figlio dell'elemento esistente Class.
\item {\bfseries ContentResource}: è un elemento le cui istanze possono essere risorse di varia natura (immagini, video, file di testo, file audio, etc.) salvate e utilizzate all'interno dell'applicazione. Anch'esso è legato con una generalizzazione all'elemento Class, mentre le cardinalità sulla relazione di composizione con Application rivelano che ogni applicazione può contenere da zero a molte risorse, mentre ogni risorsa risiede ed è accessibile da un'unica applicazione.
\item {\bfseries ExternalLibrary}: ci si riferisce ad una specifica libreria esterna di sistema, necessaria per il corretto funzionamento dell'applicazione. L'indipendenza dalla specifica applicazione si può intuire dal fatto che il concetto è introdotto come figlio di Subsystem, e non di Class. Le librerie esterne vengono considerate dei sottosistemi indipendenti, in quanto non sono altro che progetti a sé stanti, i cui sorgenti vengono sfruttati per soddisfare le funzionalità richieste dall'applicazione.\\
Osservando, quindi, le cardinalità sulla composizione che lega i due concetti di ExternalLibrary e Application, si può asserire che ogni applicazione può utilizzare da zero a molte librerie esterne, le quali devono essere importate nei sorgenti dell'applicazione. Per questo motivo la relazione inversa indica che ogni libreria esterna è utilizzata da un'unica applicazione.
\item {\bfseries SQLite}: così come ExternalLibrary anche questo elemento è rappresentato con una generalizzazione verso l'oggetto Subsystem e viene interpretato come l'insieme di tutte le librerie e gli oggetti necessari alla costruzione di un funzionale database interno al dispositivo sul quale l'applicazione verrà installata. SQLite potrebbe essere considerato figlio dell'elemento più generico ExternalLibrary, ma la scelta di collegare la generalizzazione con Subsystem ha l'obiettivo di mettere in maggior risalto il concetto generico di SQLite, inteso come strumento che permette di realizzare una base di dati incorporata in un unico file e che risulta compatibile con diverse piattaforme mobili, tra cui Android e iOS.\\
La relazione di composizione ha cardinalità 0..1 verso l'elemento SQLite a significare che l'applicazione può opzionalmente incorporare un database SQLite, mentre dall'altro capo la cardinalità è uno in quanto ogni database è legato alla specifica applicazione che lo gestisce.
\item {\bfseries Menu}: è inteso come menu principale dell'applicazione e, in quanto tale, è definito come figlio del concetto astratto {\bfseries NavigationStarter}, da intendersi come generico punto di partenza di una navigazione all'interno dell'applicazione.
\item {\bfseries ViewController}: si tratta di un elemento di fondamentale importanza nelle applicazioni mobili, e in particolare rappresenta le Activity in ambiente Android e i ViewController in ambiente iOS. Nel pattern MVC riveste i ruoli di View e Controller allo stesso tempo, in quanto costituisce l'oggetto alla base della gestione dei contenuti dei componenti mostrati sull'interfaccia grafica.
Nel metamodello ViewController è indicato come figlio di Class, perciò le istanze di ViewController possono comprendere attributi e metodi. Considerando le cardinalità della relazione di composizione tra Application e ViewController si evince che ogni ViewController appartiene ad un'unica applicazione, mentre ogni applicazione può avere molti ViewController o addirittura nessuno, sebbene in quel caso si tratterebbe di un'applicazione priva di interfaccia grafica e quindi di utilità pratica.\\ 
\end{itemize}
Collegati al concetto di ViewController vi sono poi diversi altri elementi, infatti esso può contenere delle istanze di LifeCycleOperation, AsyncTask e Navigation e può avere accesso ad elementi grafici e risorse hardware.
\\\\
Per {\bfseries LifeCycleOperation} si intende un generico metodo per la gestione del ciclo di vita di un ViewController dell'applicazione. In quanto metodo lo stereotipo LifeCycleOperation è figlio dell'elemento Operation. In Figura \ref{fig:lifeCycle} è mostrato un confronto diretto tra i metodi maggiormente utilizzati per la gestione del ciclo di vita delle Activity in Android e dei ViewController in iOS, dove emergono alcune corrispondenze.
\begin{figure} [h!]
\centering
\includegraphics[width=\textwidth]{Figure/Cap2/LifeCycle-iOSvsAndroid.pdf}
\caption{{\itshape Android e iOS}: Life Cycle}
\label{fig:lifeCycle}
\end{figure}\\
Dall'analisi a monte della modellazione sono stati introdotti i seguenti concetti, presenti nel metamodello come figli concreti dell'elemento astratto LifeCycleOperation, presente in Figura \ref{fig:metamodelloParteEstesa}:
\begin{itemize}
\item {\bfseries Create}: fa riferimento alla onCreate in Android e alla viewDidLoad in iOS, ovvero al primo metodo invocato sul ViewController al momento della sua creazione. 
\item {\bfseries Appear}: fa riferimento alla onStart e alla onResume in Android e alla viewWillAppear e alla viewDidAppear in iOS, invocati in prossimità dell'apparizione dell'interfaccia grafica del relativo ViewController sullo schermo.
\item {\bfseries Disappear}: fa riferimento alla onPause e alla onStop in Android e alla viewWillDisappear e alla viewDidDisappear in iOS, invocati al momento della scomparsa dell'interfaccia grafica del relativo ViewController dallo schermo.
\item {\bfseries Destroy}: fa riferimento alla onDestroy in Android e alla dealloc in iOS, ovvero al metodo invocato sul ViewController al momento della suo cancellazione dalla memoria del dispositivo.
\end{itemize}
L'associazione che lega ViewController a LifeCycleOperation ha cardinalità uno verso il ViewController, ad indicare che ogni metodo del ciclo di vita è implementato all'interno del relativo ViewController, mentre da uno a molti nell'altro senso, in quanto ogni ViewController può contenere diversi metodi di gestione del ciclo di vita, e in particolare deve necessariamente contenere l'implementazione del metodo Create.
\begin{figure}[h!]
\centering
\includegraphics[scale=0.8]{Figure/Cap2/Metamodel-LifeCycleOperationPart.pdf}
\caption{{\itshape Metamodello Astratto}: parte nuova - metodi del ciclo di vita.}
\label{fig:metamodelLifeCycle}
\end{figure}
\\\\
Entrambe le piattaforme Android e iOS offrono la possibilità di eseguire blocchi di codice in maniera asincrona rispetto al task principale di esecuzione, perciò è stato introdotto l'elemento {\bfseries AsyncTask}. L'associazione che lega ViewController a AsyncTask mostra la possibilità per un ViewController di istanziare e quindi utilizzare zero o più task asincroni. 
\\\\
L'ultimo elemento che rimane da analizzare prima di affrontare la parte relativa all'interfaccia grafica è {\bfseries Navigation}. Con questo concetto vogliamo modellare la possibilità di passare da un ViewController ad un'altro all'interno dell'applicazione. Ogni oggetto Navigation è composto quindi da un punto di partenza e un punto di arrivo e per questo motivo nel diagramma sono indicate due relazioni di composizione. La prima, contraddistinta dal nome {\itshape start}, è diretta verso l'elemento NavigationStarter, da cui la navigazione ha origine, invece la seconda, contraddistinta dall'etichetta {\itshape end}, è diretta verso un nuovo ViewController. Considerando le generalizzazioni sull'elemento NavigationStarter la navigazione ha origine nel momento in cui viene cliccata una voce del menu principale oppure quando si verificano determinati eventi su qualcuno degli elementi dell'interfaccia grafica.\\
Abbiamo definito Navigation come elemento figlio di Association proprio perché una navigazione all'interno dell'applicazione rappresenta un'associazione tra due componenti interne.

\subsection{Interfaccia grafica}
I ViewController dell'applicazione sono costituiti da una {\bfseries Window}, a sua volta composta da zero a molte View, ciascuna delle quali rappresenta uno specifico componente grafico mostrato sullo schermo. Una Window priva di View non è altro che un semplice ViewController privo di interfaccia grafica.\\
Come si evince dal metamodello, View, in quanto figlio di NavigationStarter, ha una relazione col concetto di Navigation, perché da una View può essere avviata una navigazione verso un nuovo ViewController al verificarsi di un determinato evento. Abitualmente gli eventi si verificano a causa dell'interazione dell'utente col dispositivo (la pressione di un bottone, l'identificazione di una particolare gesture, l'immissione di un testo, etc), ma possono essere scatenati anche dal sistema stesso. I metodi che catturano gli eventi sono chiamati {\bfseries Listener} e in quanto tali sono figli di Operation. Ogni View può avere diversi Listener associati, uno per ciascuno degli eventi scatenabili che si intende monitorare. 
\\\\
I principali elementi che caratterizzano l'interfaccia grafica sono stati indicati esplicitamente nel metamodello come figli dell'elemento astratto View. Tali elementi, che trovano spazio all'interno delle Window dei vari ViewController, sono rappresentati in Figura \ref{fig:metamodelloGUI} e descritti sinteticamente di seguito.
\begin{figure} [ht]
\centering
\includegraphics[width=\textwidth]{Figure/Cap2/Metamodel-ViewPart.pdf}
\caption{{\itshape Metamodello Astratto}: parte nuova - GUI.}
\label{fig:metamodelloGUI}
\end{figure}
\\
\begin{itemize}
\item {\bfseries Button}: è un bottone che può essere premuto dall'utente per compiere una determinata azione. Solitamente al bottone è associato il Listener per catturare il click scatenato dall'utente.
\item {\bfseries ImageView}: mostra un'immagine o un'icona caricata dalle risorse, scaricata da Internet o estratta dalla memoria del dispositivo.
\item  {\bfseries VideoView}: mostra un video caricato dalle risorse, scaricato da Internet o estratto dalla memoria del dispositivo.
\item {\bfseries TextView}: è un'area di testo non editabile.
\item {\bfseries EditText}: è un'area di testo il cui contenuto può essere modificato dall'utente.
\item {\bfseries ListView}: rappresenta una lista di elementi con scorrimento verticale.
\item {\bfseries GridView}: rappresenta una collezione di elementi disposti su una griglia con scorrimento bidimensionale.
\item {\bfseries WebView}: permette di visualizzare una pagina web all'interno del ViewController, per cui i suoi contenuti e il layout sono definiti attraverso file HTML e CSS estratti dalle risorse.
\item {\bfseries MapView}: mostra una mappa geografica con eventuali marker o percorsi indicati.
\item {\bfseries AlertDialog}: è un messaggio che viene mostrato in sovraimpressione sullo schermo del dispositivo e richiede tipicamente la scelta di una o più opzioni all'utente.
\item {\bfseries ProgressDialog}: è un messaggio simile all'AlertDialog ma con la differenza di essere utilizzato per informare l'utente che l'applicazione sta eseguendo delle operazioni che richiedono del tempo e di cui è necessario attenderne il completamento. Può essere la tipica rotellina (spinner) o una barra orizzontale che mostra la percentuale di completamento dell'operazione.
\end{itemize}

\subsection{Hardware}
Nel primo capitolo abbiamo visto che uno dei punti di forza delle applicazioni sviluppate in linguaggio nativo è la possibilità di utilizzare tutte le API dei componenti hardware del dispositivo sul quale vengono installate. Quindi, all'interno di un metamodello che si propone di presentare i componenti principali che strutturano le applicazioni mobili, non può mancare una parte dedicata all'accesso e alla gestione delle risorse hardware. I componenti di questa parte sono illustrati sia in Figura \ref{fig:metamodelloParteEstesa} che in Figura \ref{fig:metamodelloHW}, dove sono rappresentati i figli dell'elemento astratto HWResource.
\begin{figure} [ht]
\centering
\includegraphics[width=\textwidth]{Figure/Cap2/Metamodel-HWResourcePart.pdf}
\caption{{\itshape Metamodello Astratto}: parte nuova - HW.}
\label{fig:metamodelloHW}
\end{figure}
\\\\
L'analisi di questa sezione può partire dall'associazione che lega ViewController e {\bfseries HWResourceController}. HWResourceController, nel metamodello definito come generica classe, è da intendersi come un elemento che consente la gestione dell'interfacciamento con una particolare risorsa hardware del dispositivo, perciò assume il ruolo di mediatore tra lo specifico ViewController che richiede l'accesso al componente hardware e il componente stesso. I ViewController possono contenere zero o più istanze di HWResourceController, a seconda che richiedano o meno l'interfacciamento con specifici componenti hardware. 
\\\\
Le risorse hardware sono invece rappresentate dal concetto {\bfseries HWResource}, anch'esso definito come figlio di Class. E' interessante notare le cardinalità dell'associazione che lega questo elemento con HWResourceController: una risorsa hardware deve avere almeno un'istanza di HWResourceController che ne gestisce l'interfacciamento, ma in generale ne ha anche più di una, mentre un HWResourceController fa riferimento ad un unico componente hardware.\\
Di seguito vengono presentati in modo sintetico gli elementi figli del concetto astratto HWResource, che costituiscono le principali risorse hardware del dispositivo sfruttabili dalle applicazioni.
\begin{itemize}
\item {\bfseries Accelerometer}: sensore in grado di misurare l'accelerazione applicata al dispositivo, inclusa quella determinata dalla forza di gravità. Risulta utile a percepire lo spostamento e in genere viene utilizzato allo scopo di cambiare automaticamente l'orientamento dell'interfaccia grafica sullo schermo da landscape a portrait e viceversa, a seconda dell'inclinazione del dispositivo. 
\item {\bfseries Gyroscope}: sensore in grado di identificare la posizione e la velocità angolare del dispositivo rispetto a uno degli assi x, y e z del dispositivo. Insieme all'accelerometro e al GPS è usato spesso per individuare più facilmente la posizione del dispositivo.
\item {\bfseries GPS}: sensore del dispositivo che riceve dal satellite le informazioni relative alle coordinate geografiche. In genere è utilizzato congiuntamente alle mappe. 
\item {\bfseries Wi-Fi}: sensore che consente al dispositivo di accedere alla rete Internet attraverso una connessione a un router Wi-Fi.
\item {\bfseries Bluetooth}: sensore che permette lo scambio di dati tra dispositivi dislocati nel raggio di pochi metri.
\item {\bfseries Light}: sensore che rileva la quantità di luce ambientale e che viene utilizzato per regolare la luminosità dello schermo.
\item {\bfseries Speaker}: componente finalizzato all'emissione dei suoni.
\item {\bfseries Camera}: componente utilizzato per scattare le foto e registrare i video. Può essere più di uno in uno stesso dispositivo.
\item {\bfseries Proximity}: sensore in grado di rilevare la presenza di oggetti nelle immediate vicinanze del dispositivo. Negli smartphone con schermo touchscreen, il sensore viene utilizzato generalmente durante le telefonate: al momento del rilevamento di una certa vicinanza del volto al dispositivo viene disattivato il touchscreen, evitando così il possibile tocco involontario dei tasti sullo schermo riattivandolo solo all'avvenuto distacco.
\end{itemize}

\section{Metamodello dell'applicazione Valtellina}
Per sondare la possibilità di utilizzare il metamodello come strumento per modellare una generica applicazione per dispositivi mobili, indipendentemente dalla piattaforma per cui viene progettata, abbiamo provato a generare una sua istanza. Tale istanza costituisce il modello di un'applicazione di quelle che proveremo a generare attraverso il generatore di codice, che costituisce l'output della fase di implementazione del nostro lavoro e che verrà quindi presentato più avanti. L'applicazione che intendiamo modellare si chiama {\bfseries Valtellina} e permette all'utente finale di accedere a una serie di informazioni e foto relative alle più rinomate località turistiche della zona.
\\\\
Essa è composta da quattro ViewController, dove il primo ad essere mostrato all'apertura dell'applicazione corrisponde a quello che presenta una descrizione generica del territorio, con una foto che riporta il marchio del territorio e un bottone che permette di accedere a un secondo ViewController, contenente un video caratteristico. L'applicazione presenta inoltre un menu che permette di accedere al primo ViewController e a un terzo che contiene una lista delle più frequentate località turistiche. A partire da quest'ultimo l'utente ha la possibilità di selezionare una voce dall'elenco e visualizzare un nuovo ViewController contenente i dettagli di quella specifica località, e in particolare una descrizione generale e una foto.
\\\\
In Figura \ref{fig:model-valtellina} è mostrato il modello dell'applicazione. Partendo dall'alto possiamo vedere come l'applicazione sia composta da un {\itshape Manifest}, che nella versione Android corrisponderà ad un file XML, e da un certo numero di risorse interne, che, per ragioni di spazio, abbiamo preferito non riportare nel modello ma che concettualmente corrispondono a tutte le immagini, al video e ai file di testo relativi alle località turistiche.
\begin{figure} [h!]
\centering
\includegraphics[width=\textwidth]{Figure/Cap2/Model-Valtellina.pdf}
\caption{{\itshape Valtellina}: istanza del metamodello.}
\label{fig:model-valtellina}
\end{figure}
\\
Osservando le altre composizioni su Application è possibile notare i quattro ViewController che abbiamo presentato poco fa: {\itshape Description}, che costituisce il ViewController iniziale, {\itshape Video}, che contiene il video, {\itshape TurismLocationsList}, composto da una lista contenente alcune località turistiche della zona, e infine {\itshape TurismLocationDetail}, che mostra i dettagli di una certa località turistica.
\\
L'ultima composizione che rimane da segnalare è quella con l'elemento Menu, che costituisce un NavigationStarter, per cui può presentare una o più relazioni con l'elemento Navigation. Nel nostro caso, a partire dal Menu dell'applicazione, è evidente nel modello l'intenzione di consentire all'utente finale di raggiungere i ViewController Description e TurismLocationsList.
\\\\
Per capire come sono strutturati i diversi ViewController e come sono legati tra loro partiamo con ordine, analizzando il primo che viene mostrato all'apertura dell'applicazione. Il ViewController {\bfseries Description} è composto, a livello concettuale, da una Window contenente gli elementi dell'interfaccia grafica, che in questo caso sono tre. Il primo indicato in figura è una ImageView chiamata {\itshape logoImageView} che è stata modellata con lo scopo di mostrare in un'immagine il marchio della Valtellina. Il secondo elemento, chiamato {\itshape descriptionWebView}, è una WebView contenente la descrizione generica del territorio: abbiamo scelto di utilizzare una WebView, in alternativa ad una TextView, per mostrare come è possibile sfruttare le tecnologie del web, nel nostro caso HTML e CSS, per definire in maniera semplice e completa, evitando di utilizzare un particolare editor grafico, il contenuto e il layout di un ViewController. L'ultimo elemento grafico, {\itshape videoButton}, è invece il bottone che permette di avviare una navigazione statica verso il ViewController {\bfseries Video}, la cui Window non contiene altro che una VideoView per la riproduzione del video.
\\\\
A partire dal menu è poi possibile raggiungere il ViewController {\bfseries TurismLocationsList}, composto da una Window contenente una ListView, chiamata {\itshape turismLocationsListView}. La ListView ha una relazione con un Listener, ad indicare che vogliamo fare in modo che l'evento di click di un particolare elemento interno alla lista venga monitorato. Al momento del click è partirà una navigazione verso il ViewController TurismLocationDetail, per questo motivo è stata indicata una relazione con l'elemento Navigation che ha come punto di arrivo proprio il ViewController contenente i dettagli della località turistica. A differenza di quelle presentate in precedenza questa navigazione è dinamica, in quanto il contenuto del ViewController destinazione è dipendente dall'elemento che è stato cliccato nella ListView interna a TurismLocationsList. Come vedremo più avanti, le navigazioni dinamiche richiedono allo sviluppatore di implementare via codice, modificando i sorgenti dell'applicazione generata, la logica applicativa che determina il passaggio delle informazioni necessarie dal ViewController di partenza al ViewController di destinazione, sebbene nella maggior parte dei casi richiede un effort minimo.
La Window dell'ultimo ViewController, {\bfseries TurismLocationDetail}, è composta da tre elementi grafici. I primi due sono semplici TextView, chiamate {\itshape titleTextView} e {\itshape descriptionTextView}, finalizzate a contenere rispettivamente il nome e un testo descrittivo della località turistica che è stata selezionata dall'utente nel ViewController precedente. Il terzo e ultimo elemento grafico è una ImageView contenente una foto della località turistica.
\\\\
Il modello presentato in questo paragrafo costituisce un'istanza del metamodello presentato: quello che possiamo affermare è che, per quanto chiaro possa apparire, esso non è completo in termini di informazioni richieste per determinare i contenuti dell'applicazione che si intende generare. Per citare un esempio, il modello presentato non permette di indicare esplicitamente le informazioni da inserire nelle TextView, o quali siano i file locali contenenti le immagini che devono essere mostrate nelle ImageView. Tutto ciò è conseguenza del fatto che quello che manca principalmente nel metamodello presentato è la definizione di attributi all'interno degli elementi che lo compongono. 

\section{Conclusioni}
In questo capitolo abbiamo visto una prima versione, ad alto livello, del metamodello per le applicazioni mobili e abbiamo provato a definire una sua istanza. Gli oggetti riportati in questa versione sono stati descritti sinteticamente, per permettere al lettore di comprendere i concetti che stanno alla base della struttura delle applicazioni mobili, indipendentemente dalla piattaforma per la quale vengono progettate. \\
Come abbiamo avuto modo di constatare attraverso il modello dell'applicazione Valtellina, le istanze del metamodello astratto si presentano tuttavia come modelli non sufficientemente espressivi da essere tradotti in codice. In altre parole, per procedere con la fase di generazione del codice, ovvero traduzione di una certa istanza del metamodello, definita dall'utente, nei corrispondenti sorgenti nativi dell'applicazione, risulta necessario partire da una versione più concreta del metamodello. Per questo motivo, nel capitolo seguente presenteremo una seconda versione, in cui molti dei concetti modellati in questo capitolo verranno ripresi, analizzati nel dettaglio e riadattati laddove necessario, con lo scopo di rendere più completo e dettagliato l'output della fase di modellazione dell'applicazione desiderata, in modo da rendere fattibile la traduzione del modello generato nei sorgenti nativi corrispondenti.